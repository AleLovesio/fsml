/**
 *       @file  fsml.lexpp
 *      @brief  The scanner definition for the FSML (Finite State Machine Language)
 *
 *
 *     @author  Niccolo` Battezzati, niccolo.battezzati@argotecgroup.com
 *
 *   @internal
 *     Created  20/09/2020
 *     Company  Argotec S.r.l
 *   Copyright  Copyright (c) 2020, Argotec S.r.l
 *
 * This source code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This source code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser Public License for more details.

 * You should have received a copy of the GNU Lesser Public License
 * along with this source code.  If not, see <http://www.gnu.org/licenses/>.
 * =====================================================================================
 */



%{
#include <stdio.h>
#include <string>
#include <errno.h>


#include "FSMLDriver.h"
/*
#include "fsml.hh" 
*/
#include "fsml_inner.h"


/*
#define yyterminate()	return token::END_OF_FILE

#define FSMLlval 		yylval 
*/


#ifdef DEBUG
#undef DEBUG
#endif

typedef FSML::FSMLParser::token token;

%}

/*
%option noyywrap nounput batch
*/



GEN_IDENTIFIER	[a-zA-Z]([a-zA-Z0-9_]*)
STRING			\"[^\"]+\"
INTEGER			[0-9]+
COMMENT			[:blank:]*#.*


IO_BANK_COMMAND		[:blank:]*"set_iobank".*
IO_COMMAND			[:blank:]*"set_io".*
HIERARCHICAL_ID		[a-zA-Z]([a-zA-Z0-9_\\\[\]/\.]*)



%%



"fsm"		{
				#ifdef DEBUG
				printf("found: FSM\n");
				#endif
				return token::FSM;
			}

"{"			{
				#ifdef DEBUG
				printf("found: LCB\n");
				#endif
				return token::LCB;
			}

"}"			{
				#ifdef DEBUG
				printf("found: RCB\n");
				#endif
				return token::RCB;
			}

"="			{
				#ifdef DEBUG
				printf("found: EQUAL\n");
				#endif
				return token::EQUAL;
			}

"input"		{
				#ifdef DEBUG
				printf("found: INPUT\n");
				#endif
				return token::INPUT;
			}

"output"	{
				#ifdef DEBUG
				printf("found: OUTPUT\n");
				#endif
				return token::OUTPUT;
			}

"state"		{
				#ifdef DEBUG
				printf("found: STATE\n");
				#endif
				return token::STATE;
			}

"["			{
				#ifdef DEBUG
				printf("found: LB\n");
				#endif
				return token::LB;
			}

"]"			{
				#ifdef DEBUG
				printf("found: RB\n");
				#endif
				return token::RB;
			}

"on"		{
				#ifdef DEBUG
				printf("found: ON\n");
				#endif
				return token::ON;
			}

"go"		{
				#ifdef DEBUG
				printf("found: GO\n");
				#endif
				return token::GO;
			}

"err"		{
				#ifdef DEBUG
				printf("found: ERR\n");
				#endif
				return token::ERR;
			}

"retry"		{
				#ifdef DEBUG
				printf("found: RETRY\n");
				#endif
				return token::RETRY;
			}

"out"		{
				#ifdef DEBUG
				printf("found: OUT\n");
				#endif
				return token::OUT;
			}

"until"		{
				#ifdef DEBUG
				printf("found: UNTIL\n");
				#endif
				return token::UNTIL;
			}

";"			{
				#ifdef DEBUG
				printf("found: SC\n");
				#endif
				return token::SC;
			}



<<EOF>>					{/*yyterminate();*/}

\n						{/*yylloc->begin.line++;*/}

{COMMENT}

.




%%

/*
#ifndef yywrap
int yywrap() 
{
	return 1;
}
#endif
*/

void FSMLDriver::scanBegin()
{
/*
	std::string msg; 
	if(!(yyin = fopen(file.c_str(), "r"))){
		msg += std::string("error opening ") + file + std::string(": ") + strerror(errno);
		error(msg);
	}
*/
}

void FSMLDriver::scanEnd()
{
/*
	fclose(yyin);
	YY_FLUSH_BUFFER;
*/
}

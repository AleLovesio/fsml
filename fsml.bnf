fsml ::= <declaration> <fsm> | <fsm>

<declaration> ::= <DECL> <c-code>

<fsm> ::= <FSM> <IDENTIFIER> { <fsm-objects-list> }

<fsm-objects-list> ::= <fsm-object>
					 | <fsm-objects-list> <fsm-object>

<fsm-object> ::= <variable-declaration> 
			   | <state>
			   | <until-retry>

<variable-declaration> ::= <variable-specifier> {<type-specifier>}+ <init-declarator> ;

<variable-specifier> ::= <VAR>
					   | <INPUT>
					   | <OUTPUT>

<type-specifier> ::= <VOID>
				   | <CHAR>
				   | <SHORT>
				   | <INT>
				   | <LONG>
				   | <FLOAT>
				   | <DOUBLE>
				   | <SIGNED>
				   | <UNSIGNED>
				   | <struct-or-union-specifier>
				   | <enum-specifier>
				   | <typedef-name>

<struct-or-union-specifier> ::= <struct-or-union> <IDENTIFIER>

<struct-or-union> ::= <STRUCT>
                    | <UNION>

<enum-specifier> ::= <ENUM> <IDENTIFIER>

<typedef-name> ::= <IDENTIFIER>

<init-declarator> ::= <declarator> = <constant>

<declarator> ::= {<pointer>}? <direct-declarator>

<direct-declarator> ::= <IDENTIFIER>

<pointer> ::= * {<pointer>}?

<constant> ::= <INTEGER-CONSTANT>
			 | <CHARACTER-CONSTANT>
			 | <FLOATING-CONSTANT>
			 | <ENUMERATION-CONSTANT>







decl {
	<c-code>
}

fsm <name> {

	var <type> <var_name> = <initializer>;
	...

	input <type> <name> = <initializer>;
	...

	output <type> <name> = <initializer>;


	state \[<id> [,<id>...]\] <name> [{ <code> }]
	on ( <condition> ) [{ <code> }] [go <name> | err | retry]
	[...]
	[out <name> { <code> }]
	;

	...

	until (<limit>) {
		
		state ... 
	} 

}

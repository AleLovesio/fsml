/* QUESTO e` un commento */
// e anche questo

// Bene, vediamo un esempio di FSML:
/* decl specifica un blocco di codice C 
   che viene integrato direttamente nel file
   cosi` com'e`, per inserire delle dichiarazioni 
   ad esempio da altri file */

decl 
// il blocco di codice C va tra {}
{

#include <memories.h>

#define MAX_RETRIES		(3)


/* questi commenti rimangono nel codice C
decl comincia con { 

// e se aggiungessi anche un commento di questo genere!?!?!

e poi finirebbe con } ma in realta`
abbiamo trovato un'altra {{{{
{{*{/ 

*/

typedef enum {
	PicState_IDLE,		// pronti per un'altra immagine
	PicState_BUSY,		// sto lavorando, aspetta!
	PicState_SHOT,		/**< enum mettiti in posa, sorridi... chack! */
	PicState_COMPLETE,	// fatto, $$$ grazie
	PicState_ERR		// c'e` stato un errore imprevisto, passate piu` tardi
} pic_state_t;

}	/* qui finisce la sezione delle dichiarazioni */


// E ora vediamo la vera e propria FSM (che significa Finite State Machine se non lo sapessi)
// La parolina magica 'fsm', guarda a caso definisce che stiamo facendo una FSM

fsm /* poi ci metti il nome della FSM*/ pic_manager {

	var pic_desc_t * pd = NULL;	

	input memory_t dest = MEMORY_CPU_RAM;

	output pic_state_t pic_state = PicState_IDLE;
	output int pippo_int = 0;						// e se io non volessi iniziare la variabile ???
	output float paperino_float = 0.4;
	

	state [start] SHOOT_PIC {
		/* shoot picture */
		pd = picture_manager_shoot(CAMERA_1, 1, 17984, 0, 0);		
		// ... done
	}
	on (pd) {
		// go to next state and wait for the shoot to be finished
	} go WAIT_METADATA on (!pd) err PicErr_SHOOT_FAILED
	out pic_state { return PicState_BUSY; };


	until (MAX_RETRIES) {

		state WAIT_METADATA 
		on (!pd) err PicErr_MEMORY_VIOLATION
		on (pd && pd->ready && pd->metadata == METADATA_READY) {
			pd = move_picture_from_payload();
		} go WAIT_TRANSF_1
		on (pd && pd->metadata == METADATA_CORRUPT) retry;


		until (MAX_RETRIES) {
			state WAIT_TRANSF_1
			on (!pd) err PicErr_MEMORY_VIOLATION
			on (pd && pd->ready && pd->memory == MEMORY_FPGA_RAM && dest != MEMORY_FPGA_RAM) {
				if (dest == MEMORY_CPU_RAM) {
					pd = move_picture_to_cpu();
				} else if (dest == MEMORY_FPGA_NAND) {
					pd = move_picture_to_nand();
				}
			} go WAIT_TRANSF_2
			on (pd && pd->ready && pd->memory == MEMORY_FPGA_RAM && dest == MEMORY_FPGA_RAM) go FINISHED
			on (pd && pd->ready && pd->memory != MEMORY_FPGA_RAM) retry
			out pic_state { return PicState_SHOT; };


			state WAIT_TRANSF_2
			on (!pd) err PicErr_MEMORY_VIOLATION
			on (pd && pd->ready && pd->memory == MEMORY_CPU_RAM) go FINISHED
			on (pd && pd->ready && pd->memory != MEMORY_CPU_RAM) retry;
		} go FINSHED;

	} err PicErr_TRANSFER_FAILED;


	state [end, err] FINISHED
	out pic_desc { return pd; }
	out pic_state { return err ? PicState_ERR : PicState_COMPLETE; };
}
